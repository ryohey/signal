from pydantic import BaseModel, Field
from typing import Optional
from enum import Enum


class GenerateRequest(BaseModel):
    prompt: str


# ============================================================================
# SongSpec Models (for deep agent architecture)
# ============================================================================


class SectionType(str, Enum):
    INTRO = "intro"
    VERSE = "verse"
    PRE_CHORUS = "pre_chorus"
    CHORUS = "chorus"
    BRIDGE = "bridge"
    OUTRO = "outro"
    SOLO = "solo"


class InstrumentSpec(BaseModel):
    name: str  # e.g., "drums", "bass", "lead_guitar"
    role: str  # e.g., "rhythm", "melody", "harmony", "texture"
    channel: int = Field(ge=0, le=15)
    program: int = Field(ge=0, le=127)
    note_range: tuple[int, int] = Field(default=(36, 84))  # MIDI note range
    style_notes: str  # e.g., "syncopated eighth notes, lock with kick"


class SectionSpec(BaseModel):
    type: SectionType
    bars: int = Field(ge=1, le=32)
    energy: str  # "low", "medium", "high", "building", "fading"
    active_instruments: list[str]  # instrument names active in this section
    notes: Optional[str] = None  # additional section-specific guidance


class ChordProgression(BaseModel):
    section_type: SectionType
    chords: list[str]  # e.g., ["Am", "F", "C", "G"]
    bars_per_chord: int = 2


class SongSpec(BaseModel):
    """Structured specification for a song, generated by planning stage."""

    tempo: int = Field(ge=40, le=240)
    key: str
    time_signature: str = "4/4"
    total_bars: int
    style: str  # genre/mood description

    instruments: list[InstrumentSpec]
    structure: list[SectionSpec]
    chord_progressions: list[ChordProgression]

    # Quality targets (used for validation)
    target_note_density: str = "medium"  # "sparse", "medium", "dense"
    target_rhythm_complexity: str = "medium"  # "simple", "medium", "complex"

    # Additional guidance
    reference_artists: Optional[list[str]] = None
    style_notes: Optional[str] = None


class TrackData(BaseModel):
    name: str
    midi_data: str  # base64 encoded
    channel: int
    program_number: int


class SongMetadata(BaseModel):
    tempo: int
    key: str
    time_signature: str


class GenerateResponse(BaseModel):
    tracks: list[TrackData]
    metadata: SongMetadata
    message: str


class RegenerateRequest(BaseModel):
    track_name: str
    instruction: str
    context: dict  # Current song state for context


class RegenerateResponse(BaseModel):
    track: TrackData
    message: str


class ErrorResponse(BaseModel):
    error: str
    detail: Optional[str] = None


# ============================================================================
# Validation Models (for deep agent architecture)
# ============================================================================


class TrackMetrics(BaseModel):
    """Metrics for a single track's MIDI data."""

    name: str
    note_count: int

    # Rhythm metrics
    eighth_note_or_faster_pct: float  # percentage of notes that are eighth or faster
    syncopation_score: float  # 0-1, how many notes are off-beat

    # Velocity metrics
    velocity_min: int
    velocity_max: int
    velocity_mean: float
    velocity_std: float

    # Density metrics
    notes_per_bar: float
    silence_pct: float  # percentage of time with no notes


class ValidationResult(BaseModel):
    """Result of MIDI quality validation."""

    passed: bool
    overall_score: float  # 0-1

    track_metrics: list[TrackMetrics]

    # Specific issues found
    issues: list[str]  # e.g., ["drums: too sparse", "bass: no syncopation"]

    # LLM review summary
    llm_review: Optional[str] = None

    # Suggestions for improvement
    suggestions: list[str]


class AttemptLog(BaseModel):
    """Log entry for a single generation attempt."""

    attempt: int
    mode: str  # "initial", "patch", "regenerate"
    code_generated: bool
    execution_success: bool
    validation_passed: bool
    error: Optional[str] = None
    validation_result: Optional[ValidationResult] = None
    issues: Optional[list[str]] = None
